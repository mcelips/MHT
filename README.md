# Заметки по коду

* Составить правила написания кода (для PHP и др.) для того, чтобы стиль у всех программистов был одинаковый, что
  упростит чтение и понимание кода, а также поиск возможных ошибок.

### Комментарии

* В начале каждого файла добавлять комментарий, в котором указывать:
    * краткое описание, что делает данный скрипт;
    * если возвращаются данные, то указать какие именно и в каком формате.
* Внутри скрипта комментировать более подробно о том, что именно выполняется в коде.

### Именование переменных и не только

* Понятное именование переменных. Например, при получении данных из таблицы `users` переменную с результатом
  называть `$result_users` или `$users`.

### Рекомендации по написанию условий

* Если в условиях после `else` вызывается ошибка `getError($num)`, то стоит изначально проверять на ошибки, а потом
  писать основной функционал. Пример условия: `if (/*...условие...*/) { /*...код...*/ } else { getError($num); }`. Более
  подробный пример приведен в разделе «Предложение по обработке ошибок для условий».

### Рекомендации по работе с базой данных

* В функцию `getError($num)` добавить закрытие соединения с базой данных `mysqli_close($connection);`. В конце всех
  файлов соединение с базой данных закрывается, НО в функции `getError($num)` вызывается `die()` и выполнение скрипта
  сразу прекращается, а так как функция `getError($num)` может быть вызвана в любом месте, то ранее открытые соединения
  с базой данных не закрываются.
* Для добавления данных в базу данных написать отдельную функцию `insert(string $table, array $data) {}`.
* Для обновления данных в базе данных написать отдельную функцию `update(string $table, array $data, $where) {}`.
* Для удаления данных из базы данных написать отдельную функцию `delete(string $table, $where) {}`.

### Новые функции

* Можно не использовать конструктор запросов для формирования запроса в базу данных, но при этом упростить написание
  запросов в базу данных. Пример приведен в разделе «Предложение по оптимизации кода обработки запросов в базу данных».
* Получение данных из массива `$_POST` вынести в отдельную функцию. Пример функции в разделе «Функция получения данных
  из массива $_POST».
* Так как проверка авторизации пользователя происходит в большинстве файлов, то функционал проверки следует вынести в
  отдельную функцию. Пример функции в разделе «Проверка авторизации пользователя по сессии».

---

## Предложение по обработке ошибок для условий

Как было сказано ранее, предлагается выводить ошибку сразу, а не писать конструкцию:

```php
if(/*...условие...*/){ /* ...какой-то_код... */ }else{ getError(/*...номер_ошибки...*/); }
```

_Пример текущей реализации:_

```php
///запрос на клиента
$prov = "SELECT * FROM `users` WHERE `id` = '$id'";
$res = mysqli_query($connection,$prov);
$numberkk = mysqli_num_rows($res);

if($numberkk != "0"){ 
    while ($row = mysqli_fetch_array($res)) {/*...*/}    
    /* ...какой-то_код... */ }
else{ 
    getError(0); 
}
```

Можно и, на мой взгляд, нужно заменить на:

```php
///запрос на клиента
$prov = "SELECT * FROM `users` WHERE `id` = '$id'";
$res = mysqli_query($connection,$prov);
$numberkk = mysqli_num_rows($res);

// Если ничего не найдено, то мы сразу прерываем выполнение скрипта
if($numberkk == "0") { getError(0); } 

// Продолжаем выполнение скрипта, так как ошибок нет
while ($row = mysqli_fetch_array($res)) {/*...*/}  
/* ...какой-то_код... */
```

_Примечание: в некоторых случаях проверка ошибок реализована в таком варианте, как предлагаю. Однако такого кода мало._

---

## Предложение по оптимизации кода обработки запросов в базу данных

_Пример текущей реализации:_

```php
///запрос на клиента
$prov = "SELECT * FROM `users` WHERE `id` = '$id'";
$res = mysqli_query($connection, $prov);
$numberkk = mysqli_num_rows($res);

if ($numberkk != "0") {
    while ($row = mysqli_fetch_array($res)) {
        $id = $row['uid'];
    }
}
```

Весь код обработчика запроса можно вынести в отдельную функцию:

```php
// ***Название функции не очень информативно, можно придумать лучше
/**
 * Обработка SQL запроса
 * @param string $query Строка запроса.
 * @return false|array Ассоциативный массив
 */
function get_result(string $query)
{
    global $connection;

    // Проверяем, что пришла строка
    // ***можно выводить ошибку
    if (false === is_string($query)) { return false; }

    // Удаляем лишние пробелы на концах строки запроса
    $query = trim($query);

    // Проверка на пустой запрос
    // ***можно выводить ошибку
    if (true === empty($query)) { return false; }

    // Обрабатываем запрос
    $result = mysqli_query($connection, $query);

    // Ошибка при выполнении запроса.
    // ***Заметка: вместо возврата FALSE лучше выбросить ошибку.
    if (false === $result) { return false; }

    // Если найдено 0 строк
    // ***Заметка: вместо возврата FALSE лучше выбросить ошибку.
    if (0 == (int)mysqli_num_rows($result)) { return false; }

    // Возвращаем результат в виде ассоциативного массива
    return mysqli_fetch_all($result, MYSQLI_ASSOC);
}
```

В итоге запрос у нас будет выглядеть так:

```php
///запрос на клиента
$query = "SELECT * FROM `users` WHERE `id` = '$id'";
$result = get_result($query);

if ($result) {
    foreach ($result as $row) {
        $id = $row['uid'];
    }
}

// ИЛИ более короткий вариант вариант
$query = "SELECT * FROM `users` WHERE id = '$id'";

if ($result = get_result($query)) {
    foreach ($result as $row) {
        $id = $row['uid'];
    }
}

```

---

# Функция получения данных из массива $_POST

```php
/**
 * Получаем данные из массива $_POST по ключу и возвращаем подготовленные для SQL запроса данные.
 * @param integer|string $key Ключ данных в массиве $_POST. 
 * @return false|string
 */
function from_post($key)
{
    global $connection;

    // Если пришел пустой ключ
    if (true === empty($key)) { return false; }

    // Если в массиве $_POST не существует такого ключа
    if (false === isset($_POST[$key])) { return false; }

    // Возвращаем подготовленные для SQL запроса данные
    return $connection->real_escape_string($_POST[$key]);
}
```

_Пример текущей реализации:_

```php
$sid = $connection->real_escape_string($_POST['sid']);
```

Пример с использованием функции `from_post($key)`:

```php
$sid = from_post('sid');
```

---

# Проверка авторизации пользователя по сессии

Так как проверка пользователя по хэшу вызывается в нескольких файлах, то данный кусок кода можно вынести в отдельную
функцию.

_Пример текущей реализации:_

```php
///запрос на клиента
$prov = "SELECT * FROM `users` WHERE `session` = '$ses'";
$res = mysqli_query($connection,$prov);
$numberkk = mysqli_num_rows($res);

if($numberkk != "0"){ /* ...какой-то_код... */ }else{ getError(0); }
```

Можно обернуть в функцию, в которой производить проверку. Если пользователь найден, то возвращаем полученный массив
данных, в ином случае выкидываем ошибку getError(0):

```php
/**
* Получаем данные пользователя по хэшу. Если сессия не найдена вызывается функция getError(0).
* @return array Данные найденного пользователя.
*/
function get_user_data($ses)
{
    global $connection;
    
    // Запрос данных пользователя
    $query = "SELECT * FROM `users` WHERE `session` = '$ses' LIMIT 1";
    $result = mysqli_query($connection, $query);
    $num_rows = mysqli_num_rows($result);
    
    // Пользователь найден
    if ($num_rows != "0") { return $result; }

    // Сессия истекла
    getError(0);
}

// ИЛИ при внедрении функции get_result(/*query*/)

function get_user($ses)
{
    global $connection;
    
    // Запрос данных пользователя
    $query = "SELECT * FROM `users` WHERE `session` = '$ses' LIMIT 1";
    $result = get_result($query);
    
    // Сессия истекла
    if (false === $result) { getError(0); }
    
    // Возвращаем полученные данные
    // Так как мы знаем, что будет только 1 пользователь, то возвращаем результат с ключом 0
    return $result[0];
}
```
